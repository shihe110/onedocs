(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{397:function(t,a,e){"use strict";e.r(a);var n=e(42),r=Object(n.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"_1-cpu时间片"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-cpu时间片"}},[t._v("#")]),t._v(" 1.cpu时间片")]),t._v(" "),e("p",[t._v("操作系统多任务执行，实际是cpu交替执行的结果。")]),t._v(" "),e("h2",{attrs:{id:"_2-进程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-进程"}},[t._v("#")]),t._v(" 2.进程")]),t._v(" "),e("p",[t._v("一个任务是一个进程，一个任务中至少包含一个子任务称之为线程。\n进程和线程的关系就是：一个进程可以包含一个或多个线程，但至少会有一个线程。")]),t._v(" "),e("p",[t._v("操作系统调度的最小单元是线程。")]),t._v(" "),e("p",[t._v("同一个应用程序，既可以有多个进程，也可以有多个线程。")]),t._v(" "),e("ul",[e("li",[t._v("多进程模式（每个进程只有一个线程）")]),t._v(" "),e("li",[t._v("多线程模式（一个进程有多个线程）")]),t._v(" "),e("li",[t._v("多进程+多线程模式")])]),t._v(" "),e("h2",{attrs:{id:"_3-进程和线程比较"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-进程和线程比较"}},[t._v("#")]),t._v(" 3.进程和线程比较")]),t._v(" "),e("ul",[e("li",[t._v("多进程的缺点"),e("br"),t._v("\n创建进程比创建线程开销大，尤其是在Windows系统上；\n进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。")]),t._v(" "),e("li",[t._v("多进程优点"),e("br"),t._v("\n多进程稳定性比多线程高，因为在多进程的情况下，一个进程崩溃不会影响其他进程，而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃。")])]),t._v(" "),e("h2",{attrs:{id:"_4-java多线程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-java多线程"}},[t._v("#")]),t._v(" 4.java多线程")]),t._v(" "),e("p",[t._v("Java语言内置了多线程支持：一个Java程序实际上是一个JVM进程，JVM进程用一个主线程来执行main()方法，在main()方法内部，我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。")]),t._v(" "),e("p",[t._v("因此，对于大多数Java程序来说，我们说多任务，实际上是说如何使用多线程实现多任务。")]),t._v(" "),e("p",[t._v("和单线程相比，多线程编程的特点在于：多线程经常需要读写共享数据，并且需要同步。例如，播放电影时，就必须由一个线程播放视频，另一个线程播放音频，两个线程需要协调运行，否则画面和声音就不同步。因此，多线程编程的复杂度高，调试更困难。")]),t._v(" "),e("p",[t._v("Java多线程编程的特点又在于：")]),t._v(" "),e("p",[t._v("多线程模型是Java程序最基本的并发模型；\n后续读写网络、数据库、Web开发等都依赖Java多线程模型。")]),t._v(" "),e("h2",{attrs:{id:"_5-创建多线程的两种方式？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-创建多线程的两种方式？"}},[t._v("#")]),t._v(" 5.创建多线程的两种方式？")]),t._v(" "),e("ul",[e("li",[t._v("继承Thread类")]),t._v(" "),e("li",[t._v("实现Runable接口")])]),t._v(" "),e("p",[t._v("Thread.setPriority(int n) // 1~10, 默认值5 设置线程优先级")]),t._v(" "),e("h2",{attrs:{id:"_6-线程状态"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-线程状态"}},[t._v("#")]),t._v(" 6.线程状态")]),t._v(" "),e("ul",[e("li",[t._v("New：新创建的线程，尚未执行；")]),t._v(" "),e("li",[t._v("Runnable：运行中的线程，正在执行run()方法的Java代码；")]),t._v(" "),e("li",[t._v("Blocked：运行中的线程，因为某些操作被阻塞而挂起；")]),t._v(" "),e("li",[t._v("Waiting：运行中的线程，因为某些操作在等待中；")]),t._v(" "),e("li",[t._v("Timed Waiting：运行中的线程，因为执行sleep()方法正在计时等待；")]),t._v(" "),e("li",[t._v("Terminated：线程已终止，因为run()方法执行完毕。")])]),t._v(" "),e("h2",{attrs:{id:"_7-线程终止的原因"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-线程终止的原因"}},[t._v("#")]),t._v(" 7.线程终止的原因")]),t._v(" "),e("ul",[e("li",[t._v("线性正常终止：run()方法执行到return语句返回")]),t._v(" "),e("li",[t._v("线性意外终止：run()方法因未捕获的异常导致线程终止")]),t._v(" "),e("li",[t._v("对某个线程的Thread实例调用stop()方法强制终止（不推荐）")])]),t._v(" "),e("h2",{attrs:{id:"_8-中断线程的方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8-中断线程的方法"}},[t._v("#")]),t._v(" 8.中断线程的方法")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("调用interrupt()方法"),e("br"),t._v("\n例子：假设从网络下载一个100M的文件，如果网速很慢，用户等得不耐烦，就可能在下载过程中点“取消”，这时，程序就需要中断下载线程的执行。")])]),t._v(" "),e("li",[e("p",[t._v("设置标志位")])])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('public class Main {\n    public static void main(String[] args)  throws InterruptedException {\n        HelloThread t = new HelloThread();\n        t.start();\n        Thread.sleep(1);\n        t.running = false; // 标志位置为false\n    }\n}\n\nclass HelloThread extends Thread {\n    public volatile boolean running = true;\n    public void run() {\n        int n = 0;\n        while (running) {\n            n ++;\n            System.out.println(n + " hello!");\n        }\n        System.out.println("end!");\n    }\n}\n')])])]),e("p",[t._v("注意到HelloThread的标志位boolean running是一个线程间共享的变量。线程间共享变量需要使用volatile关键字标记，确保每个线程都能读取到更新后的变量值。")]),t._v(" "),e("h2",{attrs:{id:"_9-volatile关键字作用？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_9-volatile关键字作用？"}},[t._v("#")]),t._v(" 9.volatile关键字作用？")]),t._v(" "),e("p",[t._v("volatile关键字解决了共享变量在线程间的可见性问题。\nvolatile关键字的目的是告诉虚拟机：")]),t._v(" "),e("ul",[e("li",[t._v("每次访问变量时，总是获取主内存的最新值；")]),t._v(" "),e("li",[t._v("每次修改变量后，立刻回写到主内存")])]),t._v(" "),e("h2",{attrs:{id:"_10-什么是守护线程？如何设置守护线程？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_10-什么是守护线程？如何设置守护线程？"}},[t._v("#")]),t._v(" 10.什么是守护线程？如何设置守护线程？")]),t._v(" "),e("p",[t._v("只要有线程不结束，jvm进程就不会退出结束。\n但有些线程的目的是无限循环的：如定时任务。")]),t._v(" "),e("ul",[e("li",[t._v("守护线程（Daemon Thread）：指为其他线程服务的线程。守护线程不会阻碍jvm退出。")]),t._v(" "),e("li",[t._v("设置守护线程：在调用start()前调用setDaemon(true)即标记该线程为守护线程")])]),t._v(" "),e("p",[t._v("注意：守护线程不能持有任何需要关闭的资源，例如打开文件等，因为虚拟机退出时，守护线程没有任何机会来关闭文件，这会导致数据丢失。")]),t._v(" "),e("h2",{attrs:{id:"_11-线程同步synchronized"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_11-线程同步synchronized"}},[t._v("#")]),t._v(" 11.线程同步synchronized")]),t._v(" "),e("p",[t._v("多线程模式下多个线程同时读写共享变量，会出现数据不一致问题。为解决该问题，即保证一段代码的原子性，通过加锁和解锁实现。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("synchronized(obj){// 获得锁\n    \n}// 释放锁\n解决了线程共享变量正确性问题，但同时带来了性能下降问题。因为synchronized代码块无法并发执行。此外，加锁和解锁需要消耗一定的时间，所以，synchronized会降低程序的执行效率。\n")])])]),e("p",[t._v("不必担心异常问题，最终都会释放锁。")]),t._v(" "),e("h2",{attrs:{id:"_12-synchronized使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_12-synchronized使用"}},[t._v("#")]),t._v(" 12.synchronized使用")]),t._v(" "),e("ul",[e("li",[t._v("找出修改共享变量的线程代码块；")]),t._v(" "),e("li",[t._v("选择一个共享实例作为锁；")]),t._v(" "),e("li",[t._v("使用synchronized(lockObject) { ... }。")])]),t._v(" "),e("p",[t._v("注：对同一共享变量的处理synchronized使用时必须获取同一把锁。对不同共享变量的多线程操作，应使用不同的锁。")]),t._v(" "),e("h2",{attrs:{id:"_13-哪些操作不需要同步synchronized"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_13-哪些操作不需要同步synchronized"}},[t._v("#")]),t._v(" 13.哪些操作不需要同步synchronized")]),t._v(" "),e("p",[t._v("JVM规范定义了几种原子操作：")]),t._v(" "),e("ul",[e("li",[t._v("基本类型（long和double除外）赋值，例如：int n = m；")]),t._v(" "),e("li",[t._v("引用类型赋值，例如：List"),e("String",[t._v(" list = anotherList。")])],1)]),t._v(" "),e("p",[t._v("long和double是64位数据，JVM没有明确规定64位赋值操作是不是一个原子操作，不过在x64平台的JVM是把long和double的赋值作为原子操作实现的。")]),t._v(" "),e("ul",[e("li",[t._v("单条原子操作不需要同步")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public void set(int m) {\n    synchronized(lock) {\n        this.value = m;\n    }\n}\n// 正解\npublic void set(String s) {\n    this.value = s;\n}\n")])])]),e("ul",[e("li",[t._v("多条赋值就必须保证同步,但有些时候，通过一些巧妙的转换，可以把非原子操作变为原子操作")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class Pair {\n    int first;\n    int last;\n    public void set(int first, int last) {\n        synchronized(this) {\n            this.first = first;\n            this.last = last;\n        }\n    }\n}\n\nclass Pair {\n    int[] pair;\n    public void set(int first, int last) {\n        int[] ps = new int[] { first, last };\n        this.pair = ps;\n    }\n}\n每个线程进入都会new一个新的局部变量所以不存在同步问题\n")])])]),e("h2",{attrs:{id:"_14-什么是同步方法？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_14-什么是同步方法？"}},[t._v("#")]),t._v(" 14.什么是同步方法？")]),t._v(" "),e("p",[t._v("使用synchronized修饰的方法是同步方法，将整个方法变成同步代码块，加锁对象是this。使用synchronized修饰静态方法，加锁对象是该方法所在类的类对象Class。")]),t._v(" "),e("p",[t._v("通过合理的设计和数据封装可以让一个类变为“线程安全”；")]),t._v(" "),e("p",[t._v("一个类没有特殊说明，默认不是thread-safe；")]),t._v(" "),e("p",[t._v("多线程能否安全访问某个非线程安全的实例，需要具体问题具体分析。")]),t._v(" "),e("h2",{attrs:{id:"_15-什么是可重入锁？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_15-什么是可重入锁？"}},[t._v("#")]),t._v(" 15.什么是可重入锁？")]),t._v(" "),e("p",[t._v("jvm允许同一个线程重复获取同一个锁，这种被同一个线程反复获取的锁，就叫做可重入锁。")]),t._v(" "),e("p",[t._v("java线程记录获取可重入锁，获取加1，退出同步代码块减1，当记录是0时，释放锁。")]),t._v(" "),e("h2",{attrs:{id:"_16-什么是死锁？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_16-什么是死锁？"}},[t._v("#")]),t._v(" 16.什么是死锁？")]),t._v(" "),e("p",[t._v("不同线程获取多个锁对象可能导致死锁。造成相互等待对方释放锁导致死锁。")]),t._v(" "),e("p",[t._v("解决：多个线程获取锁的顺序要一致。")]),t._v(" "),e("p",[t._v("a线程要先后获取s1、s2锁。b线程也要先后获取s1、s2锁。a获取s1锁，b就必须等待a释放s1后才能获取。")]),t._v(" "),e("h2",{attrs:{id:"_17-多线程协调wait、notify、notifyall"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_17-多线程协调wait、notify、notifyall"}},[t._v("#")]),t._v(" 17.多线程协调wait、notify、notifyAll")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("在synchronized内部可以调用wait()使线程进入等待状态；")])]),t._v(" "),e("li",[e("p",[t._v("必须在已获得的锁对象上调用wait()方法；")])]),t._v(" "),e("li",[e("p",[t._v("在synchronized内部可以调用notify()或notifyAll()唤醒其他等待线程；")])]),t._v(" "),e("li",[e("p",[t._v("必须在已获得的锁对象上调用notify()或notifyAll()方法；")])]),t._v(" "),e("li",[e("p",[t._v("已唤醒的线程还需要重新获得锁后才能继续执行。")])])]),t._v(" "),e("h2",{attrs:{id:"_18-reentrantlock使用？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_18-reentrantlock使用？"}},[t._v("#")]),t._v(" 18.ReentrantLock使用？")]),t._v(" "),e("p",[t._v("ReentrantLock是一个高级的处理并发的包java.util.concurrent.")]),t._v(" "),e("p",[t._v("synchronized加锁代码，在获取锁时会一直等待，一旦死锁就只能结束jvm才能结束线程。")]),t._v(" "),e("p",[t._v("ReentrantLock提供了一些额外尝试机制，如可以设置尝试获取锁的时间。")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("ReentrantLock可以替代synchronized进行同步；")])]),t._v(" "),e("li",[e("p",[t._v("ReentrantLock获取锁更安全；")])]),t._v(" "),e("li",[e("p",[t._v("必须先获取到锁，再进入try {...}代码块，最后使用finally保证释放锁；")])]),t._v(" "),e("li",[e("p",[t._v("可以使用tryLock()尝试获取锁。")])])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("if (lock.tryLock(1, TimeUnit.SECONDS)) {\n    try {\n        ...\n    } finally {\n        lock.unlock();\n    }\n}\n")])])]),e("h2",{attrs:{id:"_19-reentrantlock的多线程协调condition？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_19-reentrantlock的多线程协调condition？"}},[t._v("#")]),t._v(" 19.ReentrantLock的多线程协调Condition？")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("await()会释放当前锁，进入等待状态；")])]),t._v(" "),e("li",[e("p",[t._v("signal()会唤醒某个等待线程；")])]),t._v(" "),e("li",[e("p",[t._v("signalAll()会唤醒所有等待线程；")])]),t._v(" "),e("li",[e("p",[t._v("唤醒线程从await()返回后需要重新获得锁。")])])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class TaskQueue {\n    private final Lock lock = new ReentrantLock();\n    private final Condition condition = lock.newCondition();\n    private Queue<String> queue = new LinkedList<>();\n\n    public void addTask(String s) {\n        lock.lock();\n        try {\n            queue.add(s);\n            condition.signalAll();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public String getTask() {\n        lock.lock();\n        try {\n            while (queue.isEmpty()) {\n                condition.await();\n            }\n            return queue.remove();\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n")])])]),e("h2",{attrs:{id:"_20-介绍readwritelock？解决多线程同时读，只有一个线程能写的问题。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_20-介绍readwritelock？解决多线程同时读，只有一个线程能写的问题。"}},[t._v("#")]),t._v(" 20.介绍ReadWriteLock？解决多线程同时读，只有一个线程能写的问题。")]),t._v(" "),e("p",[t._v("解决问题：写入时只允许一个线程可以保证安全，但读取时使用锁会降低效率。")]),t._v(" "),e("p",[t._v("需求：允许多个线程同时读，但只要有一个线程在写，其他线程（不论读写）就必须等待")]),t._v(" "),e("p",[t._v("使用ReadWriteLock可以解决这个问题，它保证：")]),t._v(" "),e("ul",[e("li",[t._v("只允许一个线程写入（其他线程既不能写入也不能读取）；")]),t._v(" "),e("li",[t._v("没有写入时，多个线程允许同时读（提高性能）。")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public class Counter {\n    private final ReadWriteLock rwlock = new ReentrantReadWriteLock();\n    private final Lock rlock = rwlock.readLock();\n    private final Lock wlock = rwlock.writeLock();\n    private int[] counts = new int[10];\n\n    public void inc(int index) {\n        wlock.lock(); // 加写锁\n        try {\n            counts[index] += 1;\n        } finally {\n            wlock.unlock(); // 释放写锁\n        }\n    }\n\n    public int[] get() {\n        rlock.lock(); // 加读锁\n        try {\n            return Arrays.copyOf(counts, counts.length);\n        } finally {\n            rlock.unlock(); // 释放读锁\n        }\n    }\n}\n")])])]),e("h2",{attrs:{id:"_21-java8读写锁stampedlock？邮戳锁，读写锁的升级版。进一步提升效率。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_21-java8读写锁stampedlock？邮戳锁，读写锁的升级版。进一步提升效率。"}},[t._v("#")]),t._v(" 21.java8读写锁StampedLock？邮戳锁，读写锁的升级版。进一步提升效率。")]),t._v(" "),e("p",[t._v("ReadWriteLock的问题，会发现它有个潜在的问题：如果有线程正在读，写线程需要等待读线程释放锁后才能获取写锁，即读的过程中不允许写，这是一种悲观的读锁。")]),t._v(" "),e("p",[t._v("StampedLock解决的是读的过程允许写，但读取过程中可以判断是否有写入，如果有则再读一遍保证数据一致性。是乐观锁。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public class Point {\n    private final StampedLock stampedLock = new StampedLock();\n\n    private double x;\n    private double y;\n\n    public void move(double deltaX, double deltaY) {\n        long stamp = stampedLock.writeLock(); // 获取写锁\n        try {\n            x += deltaX;\n            y += deltaY;\n        } finally {\n            stampedLock.unlockWrite(stamp); // 释放写锁\n        }\n    }\n\n    public double distanceFromOrigin() {\n        long stamp = stampedLock.tryOptimisticRead(); // 获得一个乐观读锁\n        // 注意下面两行代码不是原子操作\n        // 假设x,y = (100,200)\n        double currentX = x;\n        // 此处已读取到x=100，但x,y可能被写线程修改为(300,400)\n        double currentY = y;\n        // 此处已读取到y，如果没有写入，读取是正确的(100,200)\n        // 如果有写入，读取是错误的(100,400)\n        if (!stampedLock.validate(stamp)) { // 检查乐观读锁后是否有其他写锁发生\n            stamp = stampedLock.readLock(); // 获取一个悲观读锁\n            try {\n                currentX = x;\n                currentY = y;\n            } finally {\n                stampedLock.unlockRead(stamp); // 释放悲观读锁\n            }\n        }\n        return Math.sqrt(currentX * currentX + currentY * currentY);\n    }\n}\n")])])]),e("ul",[e("li",[e("p",[t._v("StampedLock提供了乐观读锁，可取代ReadWriteLock以进一步提升并发性能；")])]),t._v(" "),e("li",[e("p",[t._v("StampedLock是不可重入锁。")])])]),t._v(" "),e("h2",{attrs:{id:"_22-concurrent集合（并发）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_22-concurrent集合（并发）"}},[t._v("#")]),t._v(" 22.Concurrent集合（并发）")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("集合接口")]),t._v(" "),e("th",[t._v("线程不安全")]),t._v(" "),e("th",[t._v("线程安全")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("List")]),t._v(" "),e("td",[t._v("ArrayList")]),t._v(" "),e("td",[t._v("CopyOnWriteArrayList")])]),t._v(" "),e("tr",[e("td",[t._v("Map")]),t._v(" "),e("td",[t._v("HashMap")]),t._v(" "),e("td",[t._v("ConcurrentHashMap")])]),t._v(" "),e("tr",[e("td",[t._v("Set")]),t._v(" "),e("td",[t._v("HashSet / TreeSet")]),t._v(" "),e("td",[t._v("CopyOnWriteArraySet")])]),t._v(" "),e("tr",[e("td",[t._v("Queue")]),t._v(" "),e("td",[t._v("ArrayDeque / LinkedList")]),t._v(" "),e("td",[t._v("ArrayBlockingQueue / LinkedBlockingQueue")])]),t._v(" "),e("tr",[e("td",[t._v("Deque")]),t._v(" "),e("td",[t._v("ArrayDeque / LinkedList")]),t._v(" "),e("td",[t._v("LinkedBlockingDeque")])])])]),t._v(" "),e("p",[t._v("使用java.util.concurrent包提供的线程安全的并发集合可以大大简化多线程编程：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("多线程同时读写并发集合是安全的；")])]),t._v(" "),e("li",[e("p",[t._v("尽量使用Java标准库提供的并发集合，避免自己编写同步代码。")])])]),t._v(" "),e("h2",{attrs:{id:"_23-java-util-concurrent原子类atomic？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_23-java-util-concurrent原子类atomic？"}},[t._v("#")]),t._v(" 23.java.util.concurrent原子类Atomic？")]),t._v(" "),e("p",[t._v("使用java.util.concurrent.atomic提供的原子操作可以简化多线程编程：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("原子操作实现了无锁的线程安全；")])]),t._v(" "),e("li",[e("p",[t._v("适用于计数器，累加器等。")])])]),t._v(" "),e("h2",{attrs:{id:"_24-什么是线程池？解决什么问题？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_24-什么是线程池？解决什么问题？"}},[t._v("#")]),t._v(" 24.什么是线程池？解决什么问题？")]),t._v(" "),e("p",[t._v("线程大量的创建和销毁需要消耗大量系统资源。\n于是使用一组线程来接收大量小任务并行分发处理就是线程池。（空间换时间-池化）")]),t._v(" "),e("p",[t._v("简单地说，线程池内部维护了若干个线程，没有任务的时候，这些线程都处于等待状态。如果有新任务，就分配一个空闲线程执行。如果所有线程都处于忙碌状态，新任务要么放入队列等待，要么增加一个新线程进行处理。")]),t._v(" "),e("p",[t._v("java库提供线程池接口：ExecutorService\n几个常用实现类：")]),t._v(" "),e("ul",[e("li",[t._v("FixedThreadPool：线程数固定的线程池；")]),t._v(" "),e("li",[t._v("CachedThreadPool：线程数根据任务动态调整的线程池；")]),t._v(" "),e("li",[t._v("SingleThreadExecutor：仅单线程执行的线程池。")])]),t._v(" "),e("p",[t._v("创建这些线程池的方法封装在：Executor类中。")]),t._v(" "),e("p",[t._v("JDK提供了ExecutorService实现了线程池功能：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("线程池内部维护一组线程，可以高效执行大量小任务；")])]),t._v(" "),e("li",[e("p",[t._v("Executors提供了静态方法创建不同类型的ExecutorService；")])]),t._v(" "),e("li",[e("p",[t._v("必须调用shutdown()关闭ExecutorService；")])]),t._v(" "),e("li",[e("p",[t._v("ScheduledThreadPool可以定期调度多个任务。")])])]),t._v(" "),e("h2",{attrs:{id:"_25-callable接口有返回值得多线程接口runable没有返回值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_25-callable接口有返回值得多线程接口runable没有返回值"}},[t._v("#")]),t._v(" 25.Callable接口有返回值得多线程接口Runable没有返回值")]),t._v(" "),e("h2",{attrs:{id:"_26-future"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_26-future"}},[t._v("#")]),t._v(" 26.Future")]),t._v(" "),e("p",[t._v("一个Future"),e("V",[t._v("接口表示一个未来可能会返回的结果，它定义的方法有：")])],1),t._v(" "),e("ul",[e("li",[t._v("get()：获取结果（可能会等待）")]),t._v(" "),e("li",[t._v("get(long timeout, TimeUnit unit)：获取结果，但只等待指定的时间；")]),t._v(" "),e("li",[t._v("cancel(boolean mayInterruptIfRunning)：取消当前任务；")]),t._v(" "),e("li",[t._v("isDone()：判断任务是否已完成。")])]),t._v(" "),e("h2",{attrs:{id:"_27-completablefuture"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_27-completablefuture"}},[t._v("#")]),t._v(" 27.CompletableFuture")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("可见CompletableFuture的优点是：\n\n异步任务结束时，会自动回调某个对象的方法；\n异步任务出错时，会自动回调某个对象的方法；\n主线程设置好回调后，不再关心异步任务的执行。\n\n\nCompletableFuture可以指定异步处理流程：\n\nthenAccept()处理正常结果；\nexceptional()处理异常结果；\nthenApplyAsync()用于串行化另一个CompletableFuture；\nanyOf()和allOf()用于并行化多个CompletableFuture。\n")])])]),e("h2",{attrs:{id:"_28-fork-join的任务原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_28-fork-join的任务原理"}},[t._v("#")]),t._v(" 28.Fork/Join的任务原理")]),t._v(" "),e("p",[t._v("类似MapReduce，拆分并行计算最后合并结果。")]),t._v(" "),e("h2",{attrs:{id:"_29-threadlocal"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_29-threadlocal"}},[t._v("#")]),t._v(" 29.ThreadLocal")]),t._v(" "),e("p",[t._v("它可以在一个线程中传递同一个对象。")]),t._v(" "),e("p",[t._v("ThreadLocal实例通常总是以静态字段初始化如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("static ThreadLocal<User> threadLocalUser = new ThreadLocal<>();\n")])])]),e("p",[t._v("所有方法可以随时获取到ThreadLocal中的对象。")]),t._v(" "),e("p",[t._v("实际上，可以把ThreadLocal看成一个全局Map<Thread, Object>：每个线程获取ThreadLocal变量时，总是使用Thread自身作为key：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Object threadLocalValue = threadLocalMap.get(Thread.currentThread());\n")])])]),e("p",[t._v("因此，ThreadLocal相当于给每个线程都开辟了一个独立的存储空间，各个线程的ThreadLocal关联的实例互不干扰。")]),t._v(" "),e("p",[t._v("注：ThreadLocal一定要在finally中清除：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("try {\n    threadLocalUser.set(user);\n    ...\n} finally {\n    threadLocalUser.remove();\n}\n")])])]),e("p",[t._v("为了保证能释放ThreadLocal关联的实例，我们可以通过AutoCloseable接口配合try (resource) {...}结构，让编译器自动为我们关闭。例如，一个保存了当前用户名的ThreadLocal可以封装为一个UserContext对象：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public class UserContext implements AutoCloseable {\n\n    static final ThreadLocal<String> ctx = new ThreadLocal<>();\n\n    public UserContext(String user) {\n        ctx.set(user);\n    }\n\n    public static String currentUser() {\n        return ctx.get();\n    }\n\n    @Override\n    public void close() {\n        ctx.remove();\n    }\n}\n")])])]),e("p",[t._v("使用的时候，我们借助try (resource) {...}结构，可以这么写：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('try (var ctx = new UserContext("Bob")) {\n    // 可任意调用UserContext.currentUser():\n    String currentUser = UserContext.currentUser();\n} // 在此自动调用UserContext.close()方法释放Th\n')])])]),e("p",[t._v("readLocal关联对象\n这样就在UserContext中完全封装了ThreadLocal，外部代码在try (resource) {...}内部可以随时调用UserContext.currentUser()获取当前线程绑定的用户名。")])])}),[],!1,null,null,null);a.default=r.exports}}]);