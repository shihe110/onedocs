(window.webpackJsonp=window.webpackJsonp||[]).push([[178],{521:function(t,e,n){"use strict";n.r(e);var i=n(42),a=Object(i.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"springsecurity认证"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#springsecurity认证"}},[t._v("#")]),t._v(" SpringSecurity认证")]),t._v(" "),n("h3",{attrs:{id:"authentication"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#authentication"}},[t._v("#")]),t._v(" Authentication")]),t._v(" "),n("p",[t._v("SpringSecurity提供了专门的认证接口：org.springframework.security.core.Authentication")]),t._v(" "),n("p",[t._v("并提供了一些认证实现类，一旦认证成功后，Authentication对象就会自动存储在用SecurityContextHolder管理的SecurityContext上下文中。")]),t._v(" "),n("h3",{attrs:{id:"认证原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#认证原理"}},[t._v("#")]),t._v(" 认证原理")]),t._v(" "),n("p",[t._v("1.通过过滤器链（FilterChainProxy）来处理请求认证信息。将认证信息构造成认证对象（Authentication）交给由认证管理器（AuthenticationManager）的authenticate方法去处理。")]),t._v(" "),n("p",[t._v("过滤器链中的主要过滤器有：\n- UsernamePasswordAuthenticationFilter：构造的认证对象类型为UsernamePasswordAuthenticationToken；并交由认证管理器的认证方法来进行认证操作。\n- BasicAuthenticationFilter：构造对象UsernamePasswordAuthenticationToken；并交由认证管理器的认证方法来进行认证操作。\n- ExceptionTranslationFilter:处理链中异常，即认证异常AuthenticationException返回代码401认证失败代码。AccessDeniedException：授权异常，返回403状态码。\n- FilterSecurityInterceptor：它是AbstractSecurityInterceptor的子类，当认证成功后，再使用AccessDecisionManager对Web路径资源（web URI）进行授权操作。")]),t._v(" "),n("p",[t._v("2.认证管理器AuthenticationManager接口。\n实现类ProviderManager，使用AuthenticationManagerBuilder来定制构建认证管理器。")]),t._v(" "),n("p",[t._v("3.ProviderManager（认证管理器类）：ProviderManager通过它authenticate方法将认证交给了一组顺序的AuthenticationProvider来完成认证。")]),t._v(" "),n("p",[t._v("4.AuthenticationProvider（认证者）：AuthenticationProvider接口包含两个方法：\n- 1.supports：是否支持认证安全过滤器缓解构造的Authentication；\n- 2.authenticate：对Authentication进行认证，若认证通过返回Authentication，若不通过则抛出异常。")]),t._v(" "),n("p",[t._v("5.DaoAuthenticationProvider：DaoAuthenticationProvider是AuthenticationProvider接口的实现，他支持认证的Authentication类型为UsernamePasswordAuthenticationToken。它在认证中主要用到了下面三个部分：\n- UserDetailsService：从指定的位置（如数据库）获得用户信息；通过比较用户信息和Authentication（UsernamePasswordAuthenticationToken）中的用户名和密码信息\n- 若认证通过则构建新的Authentication（UsernamePasswordAuthenticationToken），包含用户的权限信息。\n- PasswordEncoder：使用PasswordEncoder将请求传来的明文密码和存储的编码后的密码进行匹配比较。")]),t._v(" "),n("h2",{attrs:{id:"配置认证管理器authenticationmanager"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#配置认证管理器authenticationmanager"}},[t._v("#")]),t._v(" 配置认证管理器AuthenticationManager")]),t._v(" "),n("p",[t._v("新建配置类继承WebSecurityConfigurerAdapter类，并实现configure方法，使用AuthenticationManagerBuilder来构建配置认证管理器AuthenticationManager")]),t._v(" "),n("div",{staticClass:"language-xml extra-class"},[n("pre",{pre:!0,attrs:{class:"language-xml"}},[n("code",[t._v("@Configuration\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        //auth.\n    }\n\n}\n")])])]),n("p",[t._v("通过配置userDetailServive或AuthenticationProvider定制认证。")])])}),[],!1,null,null,null);e.default=a.exports}}]);